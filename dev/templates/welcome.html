<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Map Coloring Game</title>
  <style>
    .map {
      display: grid;
      grid-template-columns: repeat(5, 50px);
      grid-template-rows: repeat(5, 50px);
      gap: 2px;
    }
    .cell {
      background-color: lightgray;
      border: 1px solid gray;
      cursor: pointer;
    }
    .logout-btn {
      position: absolute;
      top: 10px;
      right: 10px;
    }
    #score {
      margin-top: 10px;
    }
    .color-palette {
      display: flex;
      gap: 5px;
      margin-top: 10px;
    }
    .color-swatch {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
    }
  </style>
</head>
<body style="background-image: url('/static/bg.jpg'); background-position: center;" class="bg-gray-100 flex justify-center items-center h-screen">
  <h1>Welcome, {{ fullname }}</h1>
  <a href="{{ url_for('logout') }}" class="logout-btn" style="background-color: #3B82F6; color: white; padding: 0.5rem 1rem; border-radius: 0.25rem; text-decoration: none; transition: background-color 0.3s ease-in-out; font-size: 14px; font-family: 'Arial', sans-serif;">Logout</a>

  <button onclick="startGame()">Start</button>
  <button onclick="reset()">Reset</button>
  <button id="displaySolutionBtn" onclick="displaySolution()" style="display: none;">Display Solution</button>
  <div id="score">Score: <span id="scoreValue">0</span></div>
  <div id="timerDisplay" style="display: none;">Time Left: <span id="timerValue">20</span> seconds</div>
  <div class="map" id="map" style="display: none;"></div>
  <div class="color-palette" style="display: none;">
    <div class="color-swatch" style="background-color: red;" onclick="changeColor('red')"></div>
    <div class="color-swatch" style="background-color: green;" onclick="changeColor('green')"></div>
    <div class="color-swatch" style="background-color: blue;" onclick="changeColor('blue')"></div>
    <div class="color-swatch" style="background-color: yellow;" onclick="changeColor('yellow')"></div>
    <div class="color-swatch" style="background-color: orange;" onclick="changeColor('orange')"></div>
    <div class="color-swatch" style="background-color: brown;" onclick="changeColor('brown')"></div>
    <div class="color-swatch" style="background-color: pink;" onclick="changeColor('pink')"></div>
    <!-- Add more color swatches as needed -->
  </div>
  
  <script>
    // JavaScript code for map coloring game
    const map = document.getElementById('map');
    const scoreValue = document.getElementById('scoreValue');
    const timerDisplay = document.getElementById('timerDisplay');
    const displaySolutionBtn = document.getElementById('displaySolutionBtn');
    let selectedColor = 'red'; // Default color
    let solutionColors = ['red', 'green', 'blue', 'yellow', 'orange', 'brown', 'pink']; // Solution colors
    let timer;

    // Create grid cells for the map
    for (let i = 0; i < 25; i++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.color = '';
      cell.addEventListener('click', () => colorCell(cell));
      map.appendChild(cell);
    }

    // Function to color a cell when clicked
    function colorCell(cell) {
      const color = selectedColor;
      const currentColor = cell.dataset.color;
      if (currentColor === color) return; // Avoid redundant coloring
      
      // Check if any adjacent cell has the same color
      if (!checkAdjacentCells(cell, color)) {
        alert('Adjacent regions cannot have the same color!');
        return;
      }
      
      cell.dataset.color = color;
      cell.style.backgroundColor = color;
      scoreValue.textContent = parseInt(scoreValue.textContent) + 1; // Increase score when coloring a cell
    }

    // Function to change the selected color
    function changeColor(color) {
      selectedColor = color;
    }

    // Function to check if adjacent cells (including diagonals) have the same color
    function checkAdjacentCells(cell, color) {
      const neighbors = getNeighbors(cell);
      for (const neighbor of neighbors) {
        if (neighbor && neighbor.dataset.color === color) {
          return false;
        }
      }
      return true;
    }

    // Function to reset the map
    function reset() {
      const cells = document.querySelectorAll('.cell');
      cells.forEach(cell => {
        cell.dataset.color = '';
        cell.style.backgroundColor = 'lightgray';
      });
      scoreValue.textContent = '0';
      displaySolutionBtn.style.display = 'none'; // Hide display solution button

    }

    // Function to get adjacent cells (including diagonals)
    function getNeighbors(cell) {
      const grid = map.children;
      const index = Array.from(grid).indexOf(cell);
      const numRows = 5;
      const numCols = 5;
      const neighbors = [];
      const offsets = [-numCols - 1, -numCols, -numCols + 1, -1, 1, numCols - 1, numCols, numCols + 1];

      for (const offset of offsets) {
        const neighborIndex = index + offset;
        const row = Math.floor(index / numCols);
        const col = index % numCols;
        const neighborRow = Math.floor(neighborIndex / numCols);
        const neighborCol = neighborIndex % numCols;

        // Check if the neighbor is within the grid boundaries
        if (
          neighborRow >= 0 && neighborRow < numRows &&
          neighborCol >= 0 && neighborCol < numCols &&
          // Exclude circular diagonals (top left to bottom right and top right to bottom left)
          !((row === 0 && neighborRow === numRows - 1) || (row === numRows - 1 && neighborRow === 0)) &&
          !((col === 0 && neighborCol === numCols - 1) || (col === numCols - 1 && neighborCol === 0))
        ) {
          neighbors.push(grid[neighborIndex]);
        } else {
          neighbors.push(null);
        }
      }

      return neighbors;
    }

// Function to start the game
// Define startButton as a global variable
const startButton = document.querySelector('button:nth-of-type(1)');
// Function to start the game
// Function to start the game
// Function to start the game
function startGame() {
  clearInterval(timer); // Clear any existing timer
  const timerValue = document.getElementById('timerValue');
  timerValue.textContent = '20'; // Reset timer value
  startButton.disabled = true;
  const grid = document.getElementById('map');
  const colorPalette = document.querySelector('.color-palette');
  grid.style.display = 'grid';
  colorPalette.style.display = 'flex';
  timerDisplay.style.display = 'block'; // Show timer
  timer = setInterval(updateTimer, 1000); // Start the timer
}



// Function to update the timer display
function updateTimer() {
  const timerValue = document.getElementById('timerValue');
  let timeLeft = parseInt(timerValue.textContent);
  if (timeLeft > 0) {
    timeLeft--;
    timerValue.textContent = timeLeft;
  } else {
    clearInterval(timer); // Stop the timer when time is up
    displaySolutionBtn.style.display = 'inline-block'; // Show display solution button
    startButton.disabled = false;

  }
}



// Function to display solution using the Greedy Coloring Algorithm
function displaySolution() {
  clearTimeout(timer); // Stop the timer
  clearInterval(timer); // Stop the timer
  const cells = document.querySelectorAll('.cell');
  const adjacentMatrix = new Array(25).fill(null).map(() => new Array(25).fill(false));

  // Initialize adjacent matrix
  cells.forEach((cell, index) => {
    const neighbors = getNeighbors(cell).filter(neighbor => neighbor !== null);
    neighbors.forEach(neighbor => {
      const neighborIndex = Array.from(map.children).indexOf(neighbor);
      adjacentMatrix[index][neighborIndex] = true;
      adjacentMatrix[neighborIndex][index] = true;
    });
  });

  const colors = new Array(25).fill(-1);

  // Greedy coloring algorithm
  for (let i = 0; i < 25; i++) {
    const availableColors = new Array(7).fill(true);

    for (let j = 0; j < 25; j++) {
      if (adjacentMatrix[i][j] && colors[j] !== -1) {
        availableColors[colors[j]] = false;
      }
    }

    for (let color = 0; color < 7; color++) {
      if (availableColors[color]) {
        colors[i] = color;
        break;
      }
    }
  }

  cells.forEach((cell, index) => {
    const colorIndex = colors[index];
    const color = solutionColors[colorIndex];
    cell.dataset.color = color;
    cell.style.backgroundColor = color;
  });
}

  </script>
</body>
</html>
